{
  "config": {
    "abort": {
      "already_configured": "Device is already configured"
    },
    "error": {
      "cannot_connect": "Failed to connect",
      "unknown": "Unexpected error",
      "already_configured": "Repeater is already configured",
      "client_already_tracked": "Client is already being tracked",
      "login_failed": "Failed to log in to repeater. Check password and try again.",
      "login_timeout": "Timed out waiting for login response",
      "contact_not_found": "Contact not found",
      "no_repeaters_found": "No repeaters found. Refresh contacts first.",
      "no_clients_found": "No clients found. Refresh contacts first.",
      "device_not_found": "Device not found in configuration"
    },
    "title": "MeshCore",
    "step": {
      "user": {
        "data": {
          "connection_type": "Connection Type"
        },
        "description": "Select how to connect to your MeshCore node",
        "title": "MeshCore Setup"
      },
      "usb": {
        "data": {
          "usb_path": "USB Device Path",
          "baudrate": "Connection Speed",
          "contact_refresh_interval": "Contact List Refresh (seconds)"
        },
        "description": "Connect to your MeshCore node via USB",
        "title": "Configure USB Connection"
      },
      "ble": {
        "data": {
          "ble_address": "Bluetooth Device",
          "contact_refresh_interval": "Contact List Refresh (seconds)"
        },
        "description": "Connect to your MeshCore node via Bluetooth",
        "title": "Configure Bluetooth Connection"
      },
      "tcp": {
        "data": {
          "tcp_host": "Host Address",
          "tcp_port": "Port",
          "contact_refresh_interval": "Contact List Refresh (seconds)"
        },
        "description": "Connect to your MeshCore node over the network",
        "title": "Configure Network Connection"
      },
      "init": {
        "data": {
          "action": "Choose an action"
        },
        "description": "Configure your MeshCore integration.\n\n{device_status}",
        "title": "MeshCore Configuration"
      },
      "add_repeater": {
        "data": {
          "repeater_name": "Available Repeaters",
          "repeater_password": "Repeater Password",
          "telemetry_enabled": "Enable Telemetry Polling (automatically polls and discovers telemetry data)",
          "repeater_update_interval": "Telemetry Refresh Rate (seconds)"
        },
        "description": "Monitor a repeater for telemetry and status",
        "title": "Add Repeater Station"
      },
      "add_client": {
        "data": {
          "client_name": "Available Clients",
          "client_update_interval": "Update Frequency (GPS and telemetry will be auto-polled/discovered)"
        },
        "description": "Track presence and battery for a client device",
        "title": "Add Tracked Client"
      },
      "manage_devices": {
        "data": {
          "selected_device": "Select Device",
          "device_action": "Action"
        },
        "description": "Manage your configured devices:\n\n{device_list}",
        "title": "Manage Monitored Devices"
      },
      "edit_repeater": {
        "data": {
          "repeater_password": "Update Password (leave blank to keep current)",
          "telemetry_enabled": "Enable Telemetry Polling (automatically polls and discovers telemetry data)",
          "repeater_update_interval": "Telemetry Refresh Rate (seconds)"
        },
        "description": "Edit settings for {device_name}",
        "title": "Edit Repeater"
      },
      "edit_client": {
        "data": {
          "client_update_interval": "Update Frequency (GPS and telemetry will be auto-polled/discovered)"
        },
        "description": "Edit settings for {device_name}",
        "title": "Edit Tracked Client"
      },
      "global_settings": {
        "data": {
          "contact_refresh_interval": "Contact Discovery (seconds)"
        },
        "description": "Configure default values for all devices",
        "title": "Global Settings"
      }
    }
  },
  "services": {
    "send_message": {
      "name": "Send Message",
      "description": "Send a message to a MeshCore node",
      "fields": {
        "node_id": {
          "name": "Node ID",
          "description": "The ID of the node to send the message to"
        },
        "message": {
          "name": "Message",
          "description": "The message text to send"
        }
      }
    },
    "send_channel_message": {
      "name": "Send channel message",
      "description": "Send a text message to a MeshCore public channel.",
      "fields": {
        "channel_idx": {
          "name": "Channel Index",
          "description": "The index number of the channel to send to."
        },
        "message": {
          "name": "Message",
          "description": "The message to send to the channel.",
	  "example": "Hello from Home Assistant!"
        },
        "entry_id": {
          "name": "Config Entry ID",
          "description": "The config entry ID if you have multiple MeshCore devices. Leave empty to use the first available device."
        }
      }
    },
    "send_ui_message": {
      "name": "Send UI Message",
      "description": "Send a message using the MeshCore UI helpers. This service reads values from 'select.meshcore_recipient_type', 'select.meshcore_channel', 'select.meshcore_contact', and 'text.meshcore_message' to determine the recipient and message content. Call this service directly from a button card for a seamless messaging interface.",
      "fields": {
        "entry_id": {
          "name": "Config Entry ID",
          "description": "The config entry ID if you have multiple MeshCore devices. Leave empty to use the first available device."
        }
        }
      },
    "execute_command": {
      "name": "Execute MeshCore Command",
      "description": "Execute a command provided by the MeshCore Python library. This is an advanced feature that provides direct access to the underlying commands interface. CAUTION: Some commands will make PERMANENT CHANGES to your node's configuration. Use with care.",
      "fields": {
        "command": {
          "name": "Command",
          "description": "The command with parameters to execute. Format is \"[command_name] [param1] [param2] ...\" Examples: - set_name \"MyDevice\" - send_msg \"f293ac\" \"Hello from Home Assistant!\" - get_bat - set_tx_power 20 - set_coords 37.7749 -122.4194"
        },
        "entry_id": {
          "name": "Config Entry ID",
          "description": "The config entry ID if you have multiple MeshCore devices. Leave empty to use the first available device."
        }
      }
    },
    "execute_command_ui": {
      "name": "Execute Command from UI",
      "description": "Execute a command using the text.meshcore_command helper entity. This service reads the command from the text helper and executes it. It will automatically clear the input field after execution.",
      "fields": {
        "entry_id": {
          "name": "Config Entry ID",
          "description": "The config entry ID if you have multiple MeshCore devices. Leave empty to use the first available device."
        }
      }
    }
  },
  "entity": {
    "sensor": {
      "node_status": {
        "name": "Node Status",
        "state": {
          "online": "Online",
          "offline": "Offline"
        }
      },
      "node_count": {
        "name": "Node Count"
      },
      "last_rssi": {
        "name": "Last RSSI"
      },
      "last_snr": {
        "name": "Last SNR"
      },
      "battery": {
        "name": "Battery"
      },
      "uptime": {
        "name": "Uptime"
      },
      "airtime": {
        "name": "Airtime"
      },
      "nb_sent": {
        "name": "Messages Sent"
      },
      "nb_recv": {
        "name": "Messages Received"
      },
      "out_path": {
        "name": "Routing Path"
      },
      "out_path_len": {
        "name": "Path Length"
      },
      "request_successes": {
        "name": "Request Successes"
      },
      "request_failures": {
        "name": "Request Failures"
      },
      "battery_voltage": {
        "name": "Battery Voltage"
      },
      "battery_percentage": {
        "name": "Battery Percentage"
      },
      "tx_power": {
        "name": "TX Power"
      },
      "latitude": {
        "name": "Latitude"
      },
      "longitude": {
        "name": "Longitude"
      },
      "frequency": {
        "name": "Frequency"
      },
      "bandwidth": {
        "name": "Bandwidth"
      },
      "spreading_factor": {
        "name": "Spreading Factor"
      },
      "status": {
        "name": "Status"
      },
      "bat": {
        "name": "Battery Voltage"
      },
      "tx_queue_len": {
        "name": "TX Queue Length"
      },
      "noise_floor": {
        "name": "Noise Floor"
      },
      "sent_flood": {
        "name": "Sent Flood Messages"
      },
      "sent_direct": {
        "name": "Sent Direct Messages"
      },
      "recv_flood": {
        "name": "Received Flood Messages"
      },
      "recv_direct": {
        "name": "Received Direct Messages"
      },
      "full_evts": {
        "name": "Full Events"
      },
      "direct_dups": {
        "name": "Direct Duplicates"
      },
      "flood_dups": {
        "name": "Flood Duplicates"
      },
      "airtime_utilization": {
        "name": "Airtime Utilization"
      },
      "rx_airtime": {
        "name": "RX Airtime"
      },
      "rx_airtime_utilization": {
        "name": "RX Airtime Utilization"
      },
      "direct_dups_rate": {
        "name": "Direct Duplicates Rate"
      },
      "flood_dups_rate": {
        "name": "Flood Duplicates Rate"
      },
      "nb_recv_rate": {
        "name": "Messages Received Rate"
      },
      "nb_sent_rate": {
        "name": "Messages Sent Rate"
      },
      "recv_direct_rate": {
        "name": "Received Direct Messages Rate"
      },
      "recv_flood_rate": {
        "name": "Received Flood Messages Rate"
      },
      "sent_direct_rate": {
        "name": "Sent Direct Messages Rate"
      },
      "sent_flood_rate": {
        "name": "Sent Flood Messages Rate"
      }
    }
  }
}
